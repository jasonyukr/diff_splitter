use std::{
    env,
    fs::{self, File},
    io::{self, BufRead, BufReader, Write},
    path::{Path, PathBuf},
};
use regex::Regex;

/// Splits a unified diff from standard input into individual files in a target directory.
///
/// Each file's diff hunk(s) are written to a corresponding file, with '@@' lines
/// generalized (line numbers before commas replaced by 'X's).
///
/// Usage:
///   cat my_diff_file.diff | ./diff_splitter <target_directory> [strip_level]
///
/// Arguments:
///   <target_directory>: The directory where the output files will be created.
///   [strip_level]: (Optional) The number of leading path components to remove
///                  from the file paths found in the diff. Defaults to 2.
fn main() -> io::Result<()> {
    // --- 1. Argument and Environment Validation ---
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("Error: Target directory not specified.");
        eprintln!("Usage: {} <target_directory> [strip_level]", args[0]);
        std::process::exit(1);
    }

    let target_dir = PathBuf::from(&args[1]);
    let strip_level: usize = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(2);

    // Create the target directory if it doesn't already exist.
    fs::create_dir_all(&target_dir)?;

    // --- 2. Splitting the Diff ---

    // Create a temporary directory for split parts.
    // The `tempfile` crate would be more robust for cleanup,
    // but for a direct stdlib translation, we'll manage manually.
    let temp_dir_prefix = "diff_parts_";
    let temp_dir = tempfile::tempdir()?; // Using tempfile crate for robust temp dir creation and cleanup.
    let temp_dir_path = temp_dir.path();

    // Store paths to the temporary diff part files
    let mut current_part_file: Option<File> = None;
    let mut part_counter = 0;

    let stdin = io::stdin();
    let mut reader = BufReader::new(stdin.lock()); // Make reader mutable
    let mut buffer = Vec::new(); // Buffer for reading lines as bytes

    // Read lines from stdin, handling non-UTF-8 characters lossily
    while reader.read_until(b'\n', &mut buffer)? != 0 {
        let line = String::from_utf8_lossy(&buffer); // Use Cow for efficiency
        let trimmed_line = line.trim_end(); // Trim trailing newlines

        if trimmed_line.starts_with("diff --") {
            // Close the previous part file if it exists
            if let Some(mut file) = current_part_file.take() {
                file.flush()?;
            }

            // Create a new temporary file for the next part
            let part_file_path = temp_dir_path.join(format!("{}{:02}", temp_dir_prefix, part_counter));
            current_part_file = Some(File::create(&part_file_path)?);
            part_counter += 1;
        }

        // Write the current line to the active part file
        if let Some(file) = &mut current_part_file {
            writeln!(file, "{}", trimmed_line)?; // Write trimmed line
        }
        buffer.clear(); // Clear buffer for the next line
    }

    // Flush and close the last part file
    if let Some(mut file) = current_part_file.take() {
        file.flush()?;
    }

    // --- 3. Processing Each Split File ---

    // Regex for generalizing @@ lines
    let re = Regex::new(r"([+-])([0-9]+)(,[0-9]+)?").unwrap();

    // Iterate through the part files generated by splitting
    for entry in fs::read_dir(temp_dir_path)? {
        let entry = entry?;
        let part_file_path = entry.path();

        // Skip directories or non-regular files
        if !part_file_path.is_file() {
            continue;
        }

        // Read part file content as bytes and convert lossily
        let part_bytes = fs::read(&part_file_path)?;
        let part_content = String::from_utf8_lossy(&part_bytes); // Use Cow for efficiency

        if part_content.trim().is_empty() {
            continue; // Skip empty files
        }

        // Extract the filename from the '+++' line
        let mut full_path: Option<PathBuf> = None;
        for line in part_content.lines() {
            if line.starts_with("+++ ") {
                let path_str = line.trim_start_matches("+++ ").split('\t').next().unwrap_or("");
                if !path_str.is_empty() {
                    full_path = Some(PathBuf::from(path_str));
                }
                break; // Found the path, no need to search further
            }
        }

        let Some(full_path_buf) = full_path else {
            // eprintln!("Warning: No '+++' line found in part file: {:?}", part_file_path);
            continue; // If no '+++' line was found, we can't process this part, so skip it.
        };

        // --- Path Stripping Logic ---
        let stripped_path = if strip_level > 0 {
            let components: Vec<&str> = full_path_buf.iter().map(|s| s.to_str().unwrap_or("")).collect();
            if components.len() > strip_level {
                // Join components from strip_level index onwards
                components[strip_level..].iter().collect::<PathBuf>()
            } else {
                // Fallback to basename if stripping is not possible
                full_path_buf.file_name().map_or_else(
                    || PathBuf::from(""), // Handle case where there's no file name
                    |os_str| PathBuf::from(os_str),
                )
            }
        } else {
            full_path_buf
        };

        // Ensure the parent directory for the output file exists
        let output_file = target_dir.join(&stripped_path);
        if let Some(parent) = output_file.parent() {
            fs::create_dir_all(parent)?;
        }

        // --- File Creation and Content Writing ---
        let mut output_file_handle = File::create(&output_file)?;

        for line in part_content.lines() {
            let trimmed_line = line.trim_end(); // Trim trailing newlines

            // Delete header lines
            if trimmed_line.starts_with("diff --") || trimmed_line.starts_with("--- ") || trimmed_line.starts_with("+++ ") {
                continue; // Skip these lines
            }

            // Process @@ lines
            if trimmed_line.starts_with("@@ ") {
                let modified_line = re.replace_all(trimmed_line, "$1XXX$3");
                writeln!(output_file_handle, "{}", modified_line)?;
            } else {
                // Write other lines as is
                writeln!(output_file_handle, "{}", trimmed_line)?; // Write trimmed line
            }
        }
    }

    println!("Processing complete. Files created in '{}'.", target_dir.display());

    // `temp_dir` will be automatically cleaned up when it goes out of scope.
    Ok(())
}

